\documentclass[11pt,a4paper]{article}

% PACKAGES FOR TITLES
\usepackage{titlesec}
\usepackage{color}

% PACKAGES FOR LANGUAGE AND FONT
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage[T1]{fontenc} % Font encoding

% PACKAGES FOR IMAGES
\usepackage{graphicx}
\graphicspath{{img/}}
\usepackage{eso-pic} % For the background picture on the title page
\usepackage{subfig} % Numbered and caption subfigures using \subfloat
\usepackage{caption} % Coloured captions
\usepackage{transparent}

% STANDARD MATH PACKAGES
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{bm}
\usepackage[overload]{empheq}  % For braced-style systems of equations

% PACKAGES FOR TABLES
\usepackage{tabularx}
\usepackage{longtable} % tables that can span several pages
\usepackage{colortbl}

% PACKAGES FOR ALGORITHMS (PSEUDO-CODE)
\usepackage{algorithm}
\usepackage{algorithmic}

% PACKAGES FOR REFERENCES & BIBLIOGRAPHY
\usepackage[colorlinks=true,linkcolor=black,anchorcolor=black,citecolor=black,filecolor=black,menucolor=black,runcolor=black,urlcolor=black]{hyperref} % Adds clickable links at references
\usepackage{cleveref}
\usepackage[square, numbers, sort&compress]{natbib} % Square brackets, citing references with numbers, citations sorted by appearance in the text and compressed
\bibliographystyle{plain} % You may use a different style adapted to your field

% PACKAGES FOR THE APPENDIX
\usepackage{appendix}

% PACKAGES FOR ITEMIZE & ENUMERATES
\usepackage{enumitem}

% OTHER PACKAGES
\usepackage{amsthm,thmtools,xcolor} % Coloured "Theorem"
\usepackage{comment} % Comment part of code
\usepackage{fancyhdr} % Fancy headers and footers
\usepackage{lipsum} % Insert dummy text
\usepackage[skins]{tcolorbox} % Create coloured boxes (e.g. the one for the key-words)
\usepackage{listings}
\usepackage{xcolor}

\renewcommand{\footnotesize}{\scriptsize}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=none,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2,
    literate={~} {$\sim$}{1}
}

\lstset{
    style=mystyle
}

\newcommand{\bea}{\begin{eqnarray}} % Shortcut for equation arrays
\newcommand{\eea}{\end{eqnarray}}
\newcommand{\e}[1]{\times 10^{#1}}  % Powers of 10 notation
\newcommand{\mathbbm}[1]{\text{\usefont{U}{bbm}{m}{n}#1}} % From mathbbm.sty
\newcommand{\pdev}[2]{\frac{\partial#1}{\partial#2}}

\input{config_files/config}

\renewcommand{\title}{DWA vs custom trajectory tracking controller: a comparison in ROS}
\newcommand{\AUTHORa}{Giuseppe Chiari}
\newcommand{\IDa}{10576799}
\newcommand{\AUTHORb}{Leonardo Gargani}
\newcommand{\IDb}{10569221}
\newcommand{\AUTHORc}{Serena Salvi}
\newcommand{\IDc}{10607377}
\newcommand{\course}{Computer Science and Engineering}
\newcommand{\supervisor}{Luca Bascetta}
\newcommand{\YEAR}{2022/2023}
\renewcommand{\abstract}{

The Dynamic Window Approach (DWA) is an online collision avoidance strategy for mobile robots.
It incorporates the dynamics of the robot by reducing the search space to only the velocities reachable within a short time interval.

In this work we first present a comparison between the DWA algorithm from the paper and its implementation in Robot Operating System (ROS).

Then, a further comparison is made between the implementation above and a custom trajectory tracking controller, which is composed of an inner linearisation law (based on the kinematic model) and an outer tracking law (based on a proportional integral controller with velocity feed-forward).

}



\begin{document}

\input{config_files/title_page}

\newpage

\renewcommand*\contentsname{Table of Contents}
\tableofcontents

\newpage



%-----------------------------------------------------------------------------
%                               INTRODUCTION
%-----------------------------------------------------------------------------

\section{Introduction}

This project aims at helping a student attending the Control of Mobile Robots course by providing a simple case study which compares the behavior of a robot controlled with DWA and of one controlled with a trajectory tracking control law.\\

The software simulates the robot, using its kinematic model, and implements the two controllers. Everything runs on ROS Melodic on Ubuntu 18.04 LTS.



%-----------------------------------------------------------------------------
%                               DWA OVERVIEW
%-----------------------------------------------------------------------------

\section{DWA overview}

This section is basically a brief overview of the Dynamic Window Approach (DWA) as presented in the original paper\footnote{\href{https://www.ri.cmu.edu/pub_files/pub1/fox_dieter_1997_1/fox_dieter_1997_1.pdf}{D. Fox, W. Burgard, S. Thrun (1997) \textit{The Dynamic Window Approach to Collision Avoidance}}}.\\

DWA is an approach to perform collision avoidance in mobile robots, while dealing with the constraints imposed by limited velocities and accelerations.

\subsection{Search Space}

This approach consists in reducing the search space to those velocities which are reachable under the dynamic constraints and are safe with respect to obstacles.

One of the core concepts of DWA is the so-called search space. It can be seen as a two-dimensional space where each point represents a tuple $(v, \omega)$ of velocities where $v$ is the linear velocity of the robot and $\omega$ is the angular velocity.\\

The search space of the possible velocities is further reduced in other two steps.

First, we consider only all the admissible velocities, which correspond to the velocities allowing the robot to stop before it reaches the closest obstacle on the corresponding curvature.

Then, we leave out all the velocities that can't be reached within a short time interval
given the limited accelerations of the robot.\\

Starting from a sequence of n future time intervals, DWA performs a forward simulation of different values for the velocities keeping them constant for those time intervals.

As a result, the simulated trajectories are all circular arcs, and the most suitable one (we will go into details when talking about the cost function) is selected.

\subsection{Optimization}

The remaining velocities are fed into the following objective function to maximize it:
$$ G(v, \omega) = \sigma(\alpha \cdot heading(v, \omega) + \beta \cdot dist(v, \omega) + \gamma \cdot vel(v, \omega)) $$

This function trades off the following aspects:
\begin{itemize}
 \item \textit{heading}, which is a measure of progress towards the goal location;
 \item \textit{dist}, which is the distance to the closest obstacle on the trajectory;
 \item \textit{vel}, which is the forward velocity of the robot.\\
\end{itemize}

Each one of the three quantities above is multiplied to its own weight ($\alpha$, $\beta$, $\gamma$), and the resulting quantity is passed to a smoothing function ($\sigma$).


%-----------------------------------------------------------------------------
%                               DWA IN ROS
%-----------------------------------------------------------------------------

\section{DWA in ROS}

\subsection{From ROS wiki}

DWA is already implemented in ROS in the \texttt{dwa\_local\_planner}\footnote{\href{https://wiki.ros.org/dwa\_local\_planner}{https://wiki.ros.org/dwa\_local\_planner}} package.

As stated in the ROS Wiki:
\begin{quote}
 ``The dwa\_local\_planner package provides a controller that drives a mobile base in the plane. This controller serves to connect the path planner to the robot. Using a map, the planner creates a kinematic trajectory for the robot to get from a start to a goal location. Along the way, the planner creates, at least locally around the robot, a value function, represented as a grid map. This value function encodes the costs of traversing through the grid cells. The controller's job is to use this value function to determine dx,dy,dtheta velocities to send to the robot.''
\end{quote}

This package is ought to be used as the planner for \texttt{move\_base}\footnote{\href{https://wiki.ros.org/move\_base}{https://wiki.ros.org/move\_base}} within the navigation stack.

In the Wiki there is the following cost function to score each trajectory:


\begin{tcolorbox}[enhanced,width=6in,center,size=fbox]

cost \textbf{=} path\_distance\_bias \textbf{*} (distance to path from the endpoint of the trajectory)\\
    \hspace*{4em}\textbf{+} goal\_distance\_bias \textbf{*} (distance to local goal from the endpoint of the trajectory)\\
    \hspace*{4em}\textbf{+} occdist\_scale \textbf{*} (maximum obstacle cost along the trajectory in obstacle cost (0-254))

\end{tcolorbox}

However, reading through the source code of the DWA ROS library, it is said that the above function is
\textit{``used for visualization only, total\_costs are not really total costs''} \footnote{\href{https://docs.ros.org/en/melodic/api/dwa\_local\_planner/html/dwa\_\_planner\_8cpp\_source.html}{https://docs.ros.org/en/melodic/api/dwa\_local\_planner/html/dwa\_\_planner\_8cpp\_source.html}}.



\subsection{ROS libray source code}

In order to use DWA in our experiment, we call the \texttt{DWAPlannerROS::computeVelocityCommands()} function which leads to the following cascading function calls:\\
\begin{enumerate}

 \item \texttt{DWAPlannerROS::computeVelocityCommands(...)}\footnote{\href{https://docs.ros.org/en/melodic/api/dwa\_local\_planner/html/dwa\_\_planner\_\_ros\_8cpp\_source.html}{https://docs.ros.org/en/melodic/api/dwa\_local\_planner/html/dwa\_\_planner\_\_ros\_8cpp\_source.html}}
 called in our \texttt{diffdrive\_traj\_ctrl.cpp}, line 78;

 \item \texttt{DWAPlannerROS::dwaComputeVelocityCommands(...)}\footnote{\href{https://docs.ros.org/en/melodic/api/dwa\_local\_planner/html/dwa\_\_planner\_\_ros\_8cpp\_source.html}{https://docs.ros.org/en/melodic/api/dwa\_local\_planner/html/dwa\_\_planner\_\_ros\_8cpp\_source.html}}
 called from the function at step 1, line 302;

 \item \texttt{DWAPlanner::findBestPath(...)}\footnote{\href{https://docs.ros.org/en/melodic/api/dwa\_local\_planner/html/dwa\_\_planner\_8cpp\_source.html}{https://docs.ros.org/en/melodic/api/dwa\_local\_planner/html/dwa\_\_planner\_8cpp\_source.html}}
 called from the function at step 2, line 209;

 \item \texttt{SimpleScoredSamplingPlanner::findBestTrajectory(...)}\footnote{\href{https://docs.ros.org/en/melodic/api/base\_local\_planner/html/simple\_\_scored\_\_sampling\_\_planner\_8cpp\_source.html}{https://docs.ros.org/en/melodic/api/base\_local\_planner/html/simple\_\_scored\_\_sampling\_\_planner\_8cpp\_source.html}}
 called from the function at step 3, line 317;

 \item \texttt{SimpleScoredSamplingPlanner::scoreTrajectory(...)}\footnote{\href{https://docs.ros.org/en/melodic/api/base\_local\_planner/html/simple\_\_scored\_\_sampling\_\_planner\_8cpp\_source.html}{https://docs.ros.org/en/melodic/api/base\_local\_planner/html/simple\_\_scored\_\_sampling\_\_planner\_8cpp\_source.html}}
 called from the function at step 4, line 105.\\

\end{enumerate}

At this point, inside \texttt{scoreTrajectory(...)} the different cost elements are evaluated to score the trajectory.

Each cost element is an instance of the abstract \texttt{base\_local\_planner::TrajectoryCostFunction} class.

These elements are contained in a \texttt{std::vector<TrajectoryCostFunction*>} vector, and in the case of DWA they are:
\begin{itemize}
 \item \texttt{base\_local\_planner::OscillationCostFunction oscillation\_costs\_}, which penalizes trajectories where the robot oscillates;
 \item \texttt{base\_local\_planner::ObstacleCostFunction obstacle\_costs\_}, which penalizes trajectories where the robot occupies illegal positions with its footprint;
 \item \texttt{base\_local\_planner::MapGridCostFunction goal\_front\_costs\_}, which prefers  trajectories that make the nose go towards (local) nose goal;
 \item \texttt{base\_local\_planner::MapGridCostFunction alignment\_costs\_}, which prefers trajectories that keep the robot nose on nose path;
 \item \texttt{base\_local\_planner::MapGridCostFunction path\_costs\_}, which prefers trajectories on global path;
 \item \texttt{base\_local\_planner::MapGridCostFunction goal\_costs\_}, which prefers trajectories that go towards (local) goal;
 \item \texttt{base\_local\_planner::TwirlingCostFunction twirling\_costs\_}, which prefers trajectories that don't spin.\\
\end{itemize}

The considered trajectories by DWA are those taken from a equi-distant discretization of the velocities that the robot can assume. For this purpose ROS has a \texttt{base\_local\_planner::SimpleTrajectoryGenerator}\footnote{\href{https://docs.ros.org/en/melodic/api/base\_local\_planner/html/classbase\_\_local\_\_planner\_1\_1SimpleTrajectoryGenerator.html}{https://docs.ros.org/en/melodic/api/base\_local\_planner/html/classbase\_\_local\_\_planner\_1\_1SimpleTrajectoryGenerator.html}} class.



%-----------------------------------------------------------------------------
%                             SETUP OF THE EXPERIMENT
%-----------------------------------------------------------------------------

\section{Setup of the experiment}

\subsection{The robot}

In our experiment we chose to simulate a small differential drive robot.\\

In particular, it is characterized by two main dimensions (specified as YAML parameters in the code):
\begin{itemize}
 \item \texttt{d} = 15 cm, which is the distance between the two motorized wheels;
 \item \texttt{r} = 3 cm, which is the radius of the two motorized wheels.\\
\end{itemize}

The precise footprint is a pentagon, just for convenience, so that when looking at it we are able to determine the orientation of the robot.
However, this is not a decisive detail since it has o influence on the robot's behavior.


\subsection{The map}

Regarding the map, it is important to highlight the different setting we have with respect to the usual DWA use.

There are two main differences:
\begin{itemize}
 \item in our setting there are no obstacles, neither fixed nor moving;
 \item the robot does not have any sensor.\\
\end{itemize}

As a consequence, we don't need both the local map and the global map, but only the local one.

Moreover, this map needs to be empty so it is generated starting from a totally white image.


\subsection{The trajectory}

The robot must follow a precise trajectory, which is used to perform all benchmarks.

In our case we chose an eight-shaped trajectory with a dimension of 2 x 1 meters.\\

In order to make DWA compute the velocities of the robot, we must feed it a goal.

This means that the complete trajectory has to be "discretized" in multiple points.
Each one of these points is passed to DWA as the current goal, and once it is reached the next point is set as the new goal. You will find a detailed explanation in the following sections.



%-----------------------------------------------------------------------------
%                               IMPLEMENTATION
%-----------------------------------------------------------------------------

\section{Implementation}

\subsection{Architecture overview}

Our implementation is composed of three packages: one simulator (\texttt{diffdrive\_kin\_sim}) and two controllers (\texttt{diffdrive\_kin\_ctrl} and \texttt{diffdrive\_dwa\_ctrl}).

The two controllers are interchangeable and are meant to always be used together with the simulator, one at a time.

\subsection{Service}

\subsubsection{\texttt{generate\_desired\_path\_service}}

The 8-shaped trajectory that the robot must follow is generated inside \texttt{eight\_traj\_gen.cpp} executed in the launch file.

As a result, the two vectors contained in the \texttt{GenerateDesiredPathService.srv} message are populated with the coordinates of all the points of the trajectory.

As soon as the service is called, during the initialization (in the \texttt{Prepare()} function) of both controllers, the complete trajectory is made available also to the controllers.


\subsection{Nodes}

\subsubsection{\texttt{diffdrive\_kin\_sim\_node}}

This node is subscribed to the \texttt{/robot\_input} topic and reads the wheels velocities.

Given those it simulates the movement of the robot and publishes the new position in both \texttt{/robot\_state} and \texttt{/odom} topics. We have decided to keep these two topics separate in order to accommodate both controllers.\\

The actual simulator is an object of the \texttt{diffdrive\_kin\_ode} class, which is initialized as follow:
\begin{lstlisting}
    simulator = new diffdrive_kin_ode(dt);
\end{lstlisting}

and contains the integration logic to update the robot pose.

\subsubsection{\texttt{diffdrive\_kin\_trajctrl\_node}}

This node is dedicated to compute the angular velocities of the two wheels given the current position of the robot and its next point in the trajectory.\\

During the initialization phase it queries the \texttt{generate\_desired\_path\_service} service and stores the complete trajectory.

Then, every time a message is published on the \texttt{/robot\_state} topic this node updates its internal values of the robot pose.\\

The \texttt{PeriodicTask()} that gets executed uses a PID controller and a linearization law (implemented in the \texttt{diffdrive\_kin\_fblin} class) to compute both the linear and the angular velocities of the robot.

As a last step, since the simulated robot is a differential drive one, the angular velocities of the two wheels are computed starting from the $(v, \omega)$ above, and the new results are published on the \texttt{/robot\_input} and \texttt{/controller\_state} topics.

\subsubsection{\texttt{diffdrive\_dwa\_trajctrl\_node}}

This node is used to interface the DWA library in ROS with the simulator.

This is due to the fact that natively DWA is used inside ROS Navigation Stack, thus it expects an odometry source and a costmap.\\

In this specific implementation only a global costmap and a planner (DWA) are used.

As the controller explained above, during the initialiation phase the service is queried. Once the trajectory is received, one point every \texttt{skipped\_goals} is set as the new plan for DWA.

Once the plan is set, the DWA controller tries to reach the new goal position by computing the necessary pair of $(v, \omega)$ velocities. As soon as the goal is reached with a certain tolerance, the next point in the trajectory is set as the new goal.\\

Lastly, the $(\omega_r,\omega_l)$ velocities are computed and published on the \texttt{/robot\_input} and \texttt{/controller\_state} topics.

The implementation of DWA and all the functions that have been used is provided by the following two files in the ROS library:
\begin{itemize}
 \item \href{https://docs.ros.org/en/melodic/api/dwa\_local\_planner/html/dwa\_\_planner\_8cpp\_source.html}{\texttt{dwa\_planner.cpp}}
 \item \href{https://docs.ros.org/en/melodic/api/dwa\_local\_planner/html/dwa\_\_planner\_\_ros\_8cpp\_source.html}{\texttt{dwa\_planner\_ros.cpp}}
\end{itemize}

(add navigation stack image)

\subsubsection{\texttt{odom\_to\_baselink\_tf\_node}}

This node is needed in order to link the \texttt{odom} and the \texttt{base\_link} coordinate frames through a simple dynamic tf.

\subsection{Frames}

Here is a list with a brief description of all the frames:
\begin{itemize}
 \item \texttt{map}, which is the coordinate system where the empty map (provided by the map server) is;
 \item \texttt{odom}, which represent the global reference system, that in this particular case its origin matches the one of the \texttt{map} frame;
 \item \texttt{base\_link}, which represrents reference system moving around together with the robot.
\end{itemize}

(add tf\_tree image)

\subsection{Topics}

Here is a list with a brief description of the topics that our nodes are subscribed to and published into:\\

\begin{itemize}

    \item \texttt{/clock}, used to synchronize all the nodes in the simulation;

    \item \texttt{/odom}, used to pass the odometry information of the robot to DWA;
        \begin{itemize}
            \item publishers:
                \begin{itemize}
                    \item \texttt{diffdrive\_kin\_sim}
                \end{itemize}
            \item subscribers:
                \begin{itemize}
                    \item \texttt{odom\_to\_baselink\_tf}
                \end{itemize}
        \end{itemize}

    \item \texttt{/robot\_state}, used to pass the odometry information of the robot to the custom controller.
        \begin{itemize}
            \item publishers:
                \begin{itemize}
                    \item \texttt{diffdrive\_kin\_sim}
                \end{itemize}
            \item subscribers:
                \begin{itemize}
                    \item \texttt{diffdrive\_kin\_trajctrl}
                \end{itemize}
        \end{itemize}

    \item \texttt{/controller\_state}, used to publish details about the controller for visualization purposes;
        \begin{itemize}
            \item publishers:
                \begin{itemize}
                    \item \texttt{diffdrive\_kin\_trajctrl}
                    \item \texttt{diffdrive\_dwa\_trajctrl}
                \end{itemize}
            \item subscribers:
                \begin{itemize}
                    \item \textit{none}
                \end{itemize}
        \end{itemize}

    \item \texttt{/robot\_input}, used to communicate $(\omega_r,\omega_l)$ computed by the controllers;
        \begin{itemize}
            \item publishers:
                \begin{itemize}
                    \item \texttt{diffdrive\_kin\_trajctrl}
                    \item \texttt{diffdrive\_dwa\_trajctrl}
                \end{itemize}
            \item subscribers:
                \begin{itemize}
                    \item \texttt{diffdrive\_kin\_sim}
                \end{itemize}
        \end{itemize}

\end{itemize}

\subsection{Launch files}

Here is a list with a brief description of all the launch files:\\
\begin{itemize}
    \item \texttt{diffdrive\_kin\_trajctrl.launch}, used to start the following nodes:
        \begin{itemize}
            \item \texttt{diffdrive\_kin\_sim}
            \item \texttt{diffdrive\_kin\_trajctrl}
            \item \texttt{eight\_traj\_gen}
            \item \texttt{world\_to\_odom} (static tf linking \texttt{world} and \texttt{odom} frames)
            \item \texttt{odom\_visualizer} (\textit{RVIZ} node to visualize data)\\
        \end{itemize}

    \item \texttt{diffdrive\_dwa\_trajctrl.launch}, used to start the following nodes:
        \begin{itemize}
            \item \texttt{diffdrive\_kin\_sim}
            \item \texttt{diffdrive\_dwa\_trajctrl}
            \item \texttt{eight\_traj\_gen}
            \item \texttt{odom\_to\_baselink\_tf}
            \item \texttt{map\_node} (\textit{map\_server} node used to provide the map)
            \item \texttt{map\_to\_odom} (static tf linking \texttt{map} and \texttt{odom} frames)
            \item \texttt{odom\_visualizer} (\textit{RVIZ} node to visualize data)
        \end{itemize}
\end{itemize}


screen rqt\_graph di quando usiamo il nostro controllore e di quando usiamo dwa (messe di fianco)


%-----------------------------------------------------------------------------
%                               PARAMETERS
%-----------------------------------------------------------------------------

\section{Parameters}

\subsection{List of parameters}

Parameters have a crucial role for the correct functioning of the nodes introduced above.\\

In this section the most relevant ones are explained:\\
\begin{itemize}

    \item \texttt{diffdrive\_kin\_sim.yaml}:
        \begin{itemize}
            \item \texttt{d}, distance between the two wheels;
            \item \texttt{r}, radius of the two wheels.\\
        \end{itemize}

    \item \texttt{eight\_traj.yaml}:
        \begin{itemize}
            \item \texttt{a}, amplitude of the eight-shaped trajectory;
            \item \texttt{w}, ratio $\frac{2 \cdot \pi }{T}$ where $T$ is the time duration of each lap;
            \item \texttt{trajectory\_length}, length of the eight-shaped trajectory;
            \item \texttt{increment\_step}, increment step when discretizing the trajectory.\\
        \end{itemize}

    \item \texttt{diffdrive\_kin\_trajctrl.yaml}:
        \begin{itemize}
            \item \texttt{Kp}, proportional gain of the PID controller;
            \item \texttt{Ki}, integral gain of the PID controller;
            \item \texttt{Kd}, derivative gain of the PID controller.\\
        \end{itemize}

    \item \texttt{diffdrive\_dwa\_trajctrl.yaml}:
        \begin{itemize}
            \item \texttt{skipped\_goals}, number of points to skip when feeding the trajectory to DWA.\\
        \end{itemize}

    \item \texttt{dwa\_planner\_params.yaml}:
        \begin{itemize}
            \item \texttt{min\_vel\_y}, minimum linear velocity along the y-axis;
            \item \texttt{max\_vel\_y}, maximum linear velocity along the y-axis;
            \item \texttt{min\_vel\_x}, minimum linear velocity along the x-axis;
            \item \texttt{max\_vel\_x}, minimum linear velocity along the x-axis;
            \item \texttt{acc\_lim\_theta}, maximum angular acceleration;
            \item \texttt{vth\_samples}, number of uniformly-sampled values of $\omega$ that DWA considers when simulating;
            \item \texttt{vx\_samples}, number of uniformly-sampled values of $v$ that DWA considers when simulating;
            \item \texttt{path\_distance\_bias}, weighting for how much the controller should stay close to the given path;
            \item \texttt{goal\_distance\_bias}, weighting for how much the controller should attempt to reach its local goal;
            \item \texttt{xy\_goal\_tolerance}, tolerance (in meters) in the x \& y distance when reaching a goal;
            \item \texttt{yaw\_goal\_tolerance}, tolerance (in radians) in yaw/rotation when reaching a goal.\\
        \end{itemize}

\end{itemize}


\subsection{Tuning}

\subsubsection{Eight-shaped trajectory}

An eight-shaped trajectory can be be described with the following analytical equations:
$$x = \texttt{a} \cdot \sin (\texttt{w} \cdot t)$$
$$y = \texttt{a} \cdot \sin (\texttt{w} \cdot t)\cdot \cos (\texttt{w} \cdot t)$$\\

In the equations above it is possible to tune two parameters: \texttt{a} and \texttt{w}.
In the presented implementation they are set to \texttt{a} = 1 and \texttt{w} = 1.

[INSERIRE IMMAGINI CON VALORI NETTAMENTE DIVERSI DI A E W] NOSTRA + UNO DIVERSO E CAPIRE COSA FA W] \\

\subsubsection{Custom controller}

The custom controller is a trajectory tracking one composed of an inner linearisation law and an outer tracking law.
The outer tracking law is based on a PID controller with tunable parameters: $K_p$, $K_i$, $K_d$.\\

The step response when using a PID controller is computed as follows:
$$ {\displaystyle u(t)=K_{\text{p}}e(t)+K_{\text{i}}\int _{0}^{t}e(\tau )\,\mathrm {d} \tau +K_{\text{d}}{\frac {\mathrm {d} e(t)}{\mathrm {d} t}}} $$ \\

Various tests have been carried out to achieve the optimal behaviour, in particular to minimize the overshoot and
the settling time while keeping an overall good stability in the PID response.\\

In the presented implementation they are set to $K_p = 0.8$, $K_i = 0.8$, $K_d = 0$.

[RIPORTARE IMMAGINE TABELLA WIKI RIFATTA DA NOI (?) + UN PO DI ESEMPI NOSTRI]

\subsubsection{DWA}

When the trajectory is generated, the eight shape is discretized over numerous points.

Due to the large number of those, they are very close to each other. This makes the robot misbehave as soon as
a new goal is set in DWA. For this reason it is best to skip some of the points in the trajectory.
This is accomplished through the \texttt{skipped\_goals} parameters, which is set to 15.\\

[IMMAGINI UNA CON IL NOSTRO VALORE E UNO VALORE ALTO E METTERNE UNO CON VALORE MINIMO E CERCARE DI MOTIVARE

... (number of points when discretizing the trajectory: t+=0.001... MAKE IT PARAMETER!!)\\

In order to simulate a differential drive robot, the following parameters have been set:

\begin{itemize}
    \item \texttt{min\_vel\_y} = 0 and \texttt{max\_vel\_y} = 0, to forbid lateral movement along the y-axis;
    \item \texttt{min\_vel\_x} = 0, to forbid backward movement along the x-axis.\\
\end{itemize}

Another parameter related to the constraints on the movement of the robot is \texttt{acc\_lim\_theta}.
To achieve the best trade-off betweeen the ability to correctly follow the trajectory and the realistic
constraints on the steering capabilities of the robot, the most suitable value for it is 10.\\

Since DWA discretely sample in the robot's control space, parameters \texttt{vth\_samples} and \texttt{vx\_samples}
play a key role in allowing a finer grained choice of velocities.
To achieve the best trade-off betweeen a wide choice of possible $(v,\omega)$ and computational effort,
the optimal values have been found to be \texttt{vth\_samples = 100} and \texttt{vx\_samples = 30}.\\

Finally, DWA provides a certain tolerance within which the goal is considered to be reached.
In particular this can be done through two parameters \texttt{yaw\_goal\_tolerance} and \texttt{xy\_goal\_tolerance}.
The former has been set to \texttt{6.3} because it is irrelevant the direction of the robot when reaching the goal
(thus $6.3 \simeq 2\pi$ in radians).
The latter has been set to \texttt{0.15} because it is a good deal between the dimension of the robot and
an approximation of the trajectory.


%-----------------------------------------------------------------------------
%                               EXPERIMENTAL RESULTS
%-----------------------------------------------------------------------------

\section{Experimental Results}

- immagini commentate
    - script singolo su bag controllore custom
    - script singolo su bag dwa
    - script confronto su bag1 + bag2




... (plots of the bags + plots of the comparison with the custom script)



%-----------------------------------------------------------------------------
%                               ENCOUNTERED PROBLEMS
%-----------------------------------------------------------------------------

\section{Encountered problems}

\subsubsection{Deprecated parameters}

During the tuning phase of DWA a trial and error approach has been carried out, finding that
a few parameters are named differently in the in the ROS library with respect to the ROS Wiki.

Such renaming was not advertised by any error nor warning, so it was difficult to spot where the problem
was when changing parameters and seeing no effect in the robot behaviour.\\

The following pair of parameters is an example:
\begin{itemize}
 \item \texttt{min\_rot\_vel} renamed into \texttt{min\_vel\_theta};
 \item \texttt{max\_rot\_vel} renamed into \texttt{max\_vel\_theta}.\\
\end{itemize}

(put screen of the doc + screen of the comments in the library)

\subsubsection{DWA used outside of ROS Navigation Stack}

Usually DWA is used inside a standard architecture which is the Navigation Stack in ROS.

However the goal of this project was to integrate DWA in the architecture with the simulator used for
the custom controller. Thereby DWA has been rearranged in a standalone mode.\\

To accomplish this, it has been necessary to provide to DWA all the information it normally expects on certain topics such as \texttt{/odom}, \texttt{/goal}, and \texttt{/map}.\\

Unfortunately there is no documentation for this kind of setup on the ROS Wiki, and the few lines of code that are present
refer to some deprecated libraries (i.e. \texttt{tf} is the one mentioned in the example, while \texttt{tf2} is the actual
supported one).

(foto di navigation stack + confronto con foto della nostra architettura)

\subsubsection{Multiple goals along the trajectory}

In a standard scenario DWA needs only the one final goal and computes the trajectory on its own.

In this project the trajectory is predefined and must be forced changing continuously the goal, otherwise the robot
would go straight to the final point of the overall eight-shaped trajectory.



%-----------------------------------------------------------------------------
%                               USAGE OF THE CODE
%-----------------------------------------------------------------------------

\section{Usage of the code}

\subsection{Installation of required ROS packages}

First of all, all the software written in this project has been tested on \textit{Ubuntu 18.04 LTS} and \textit{ROS Melodic}.\\

In order to install ROS and all the required packages, execute:

\begin{lstlisting}
sudo apt instal ros-melodic-desktop-full
sudo apt install ros-melodic-costmap-2d ros-melodic-base-local-planner ros-melodic-dwa-local-planner ros-melodic-map-server
\end{lstlisting}




\subsection{Initial set up and compilation}

Clone or download the repository into your home ($\sim$) folder.\\

If you use bash, add the following line to the end of your .bashrc:
\begin{lstlisting}
source ~/ROS_trajectory_tracking_controller/devel/setup.bash
\end{lstlisting}

If you use zsh, add instead this other line to the end of your .zshrc:
\begin{lstlisting}
source ~/ROS_trajectory_tracking_controller/devel/setup.zsh
\end{lstlisting}

Enter the project root directory and compile everything with:
\begin{lstlisting}
cd ROS_trajectory_tracking_controller
catkin_make
\end{lstlisting}

\subsection{Run simulation and plot results}

The following instructions let you perform and visualize a simulation.

\subsubsection{Trajectory control for differential drive}

This simulation shows the behavior of the custom controller when an 8-shaped trajectory is set.\\

\textit{[terminal 1]} Start the simulation:
\begin{lstlisting}
roslaunch diffdrive_kin_ctrl diffdrive_kin_trajctrl.launch
\end{lstlisting}


\textit{[terminal 2]} Enter the \texttt{script/} folder and record the simulation:
\begin{lstlisting}
cd ~/ROS_trajectory_tracking_controller/src/diffdrive_kin_ctrl/script
rosbag record -a -O diffdrive_kin_trajctrl.bag
\end{lstlisting}

Wait about 30 seconds so that the simulation can be performed.\\

\textit{[terminal 2]} Stop the recording with Ctrl-C.\\

\textit{[terminal 1]} Stop the simulation with Ctrl-C.\\

\textit{[terminal 2]} Visualize the results:
\begin{lstlisting}
python plot_results.py diffdrive_kin_trajctrl.bag
\end{lstlisting}

\subsubsection{DWA for differential drive}

This simulation shows the behavior of DWA when an 8-shaped trajectory is set.\\

\textit{[terminal 1]} Start the simulation:
\begin{lstlisting}
roslaunch diffdrive_dwa_ctrl diffdrive_dwa_trajctrl.launch
\end{lstlisting}

\textit{[terminal 2]} Enter the script/ folder and record the simulation:
\begin{lstlisting}
cd ~/ROS_trajectory_tracking_controller/src/diffdrive_kin_ctrl/script
rosbag record -a -O diffdrive_dwa_trajctrl.bag
\end{lstlisting}

Wait about 30 seconds so that the simulation can be performed.\\

\textit{[terminal 2]} Stop the recording with Ctrl-C.\\

\textit{[terminal 1]} Stop the simulation with Ctrl-C.\\

\textit{[terminal 2]} Visualize the results:
\begin{lstlisting}
python plot_results.py diffdrive_dwa_trajctrl.bag
\end{lstlisting}


\subsubsection{Compare two simulations}

If you wish, you can also compare the results of two different simulations.

Given the two bag files named diffdrive\_dwa\_trajctrl.bag and diffdrive\_kin\_trajctrl.bag, visualize the comparison:
\begin{lstlisting}
python plot_comparison.py diffdrive\_dwa\_trajctrl.bag diffdrive\_kin\_trajctrl.bag
\end{lstlisting}


%-----------------------------------------------------------------------------
%                               CONCLUSIONS
%-----------------------------------------------------------------------------

\section{Conclusions}











\end{document}
