\documentclass[11pt,a4paper]{article} 

% PACKAGES FOR TITLES
\usepackage{titlesec}
\usepackage{color}

% PACKAGES FOR LANGUAGE AND FONT
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage[T1]{fontenc} % Font encoding

% PACKAGES FOR IMAGES
\usepackage{graphicx}
\graphicspath{{img/}}
\usepackage{eso-pic} % For the background picture on the title page
\usepackage{subfig} % Numbered and caption subfigures using \subfloat
\usepackage{caption} % Coloured captions
\usepackage{transparent}

% STANDARD MATH PACKAGES
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{bm}
\usepackage[overload]{empheq}  % For braced-style systems of equations

% PACKAGES FOR TABLES
\usepackage{tabularx}
\usepackage{longtable} % tables that can span several pages
\usepackage{colortbl}

% PACKAGES FOR ALGORITHMS (PSEUDO-CODE)
\usepackage{algorithm}
\usepackage{algorithmic}

% PACKAGES FOR REFERENCES & BIBLIOGRAPHY
\usepackage[colorlinks=true,linkcolor=black,anchorcolor=black,citecolor=black,filecolor=black,menucolor=black,runcolor=black,urlcolor=black]{hyperref} % Adds clickable links at references
\usepackage{cleveref}
\usepackage[square, numbers, sort&compress]{natbib} % Square brackets, citing references with numbers, citations sorted by appearance in the text and compressed
\bibliographystyle{plain} % You may use a different style adapted to your field

% PACKAGES FOR THE APPENDIX
\usepackage{appendix}

% PACKAGES FOR ITEMIZE & ENUMERATES 
\usepackage{enumitem}

% OTHER PACKAGES
\usepackage{amsthm,thmtools,xcolor} % Coloured "Theorem"
\usepackage{comment} % Comment part of code
\usepackage{fancyhdr} % Fancy headers and footers
\usepackage{lipsum} % Insert dummy text
\usepackage{tcolorbox} % Create coloured boxes (e.g. the one for the key-words)
\usepackage{listings}

\newcommand{\bea}{\begin{eqnarray}} % Shortcut for equation arrays
\newcommand{\eea}{\end{eqnarray}}
\newcommand{\e}[1]{\times 10^{#1}}  % Powers of 10 notation
\newcommand{\mathbbm}[1]{\text{\usefont{U}{bbm}{m}{n}#1}} % From mathbbm.sty
\newcommand{\pdev}[2]{\frac{\partial#1}{\partial#2}}

\input{config_files/config}

\renewcommand{\title}{DWA vs custom trajectory tracking controller: a comparison in ROS}
\newcommand{\AUTHORa}{Giuseppe Chiari}
\newcommand{\IDa}{10576799}
\newcommand{\AUTHORb}{Leonardo Gargani}
\newcommand{\IDb}{10569221}
\newcommand{\AUTHORc}{Serena Salvi}
\newcommand{\IDc}{10607377}
\newcommand{\course}{Computer Science and Engineering}
\newcommand{\supervisor}{Luca Bascetta}
\newcommand{\YEAR}{2022/2023}
\renewcommand{\abstract}{

The Dynamic Window Approach (DWA) is an online collision avoidance strategy for mobile robots.
It incorporates the dynamics of the robot by reducing the search space to only the velocities reachable within a short time interval.

In this work we first present a comparison between the DWA algorithm from the paper and its implementation in Robot Operating System (ROS).

Then, a further comparison is made between the implementation above and a custom trajectory tracking controller, which is composed of an inner linearisation law (based on the kinematic model) and an outer tracking law (based on a proportional integral controller with velocity feed-forward).

}



\begin{document}

\input{config_files/title_page}

\newpage

\renewcommand*\contentsname{Table of Contents}
\tableofcontents

\newpage



%-----------------------------------------------------------------------------
%                               INTRODUCTION
%-----------------------------------------------------------------------------

\section{Introduction}

This project aims at helping a student attending the Control of Mobile Robots course by providing a simple case study which compares the behavior of a robot controlled with DWA and of one controlled with a trajectory tracking control law.\\

The software simulates the robot, using its kinematic model, and implements the two controllers. Everything runs on ROS Melodic on Ubuntu 18.04 LTS.



%-----------------------------------------------------------------------------
%                               DWA OVERVIEW
%-----------------------------------------------------------------------------

\section{DWA overview}

This section is basically a brief overview of the Dynamic Window Approach (DWA) as presented in the original paper\footnote{D. Fox, W. Burgard, S. Thrun (1997) \textit{The Dynamic Window Approach to Collision Avoidance}}.\\

DWA is an approach to perform collision avoidance in mobile robots, while dealing with the constraints imposed by limited velocities and accelerations.

\subsection{Search Space}

This approach consists in reducing the search space to those velocities which are reachable under the dynamic constraints and are safe with respect to obstacles.

One of the core concepts of DWA is the so-called search space. It can be seen as a two-dimensional space where each point represents a tuple $(v, \omega)$ of velocities where $v$ is the linear velocity of the robot and $\omega$ is the angular velocity.\\

The search space of the possible velocities is further reduced in other two steps.

First, we consider only all the admissible velocities, which correspond to the velocities allowing the robot to stop before it reaches the closest obstacle on the corresponding curvature.

Then, we leave out all the velocities that can't be reached within a short time interval
given the limited accelerations of the robot.\\

Starting from a sequence of n future time intervals, DWA performs a forward simulation of different values for the velocities keeping them constant for those time intervals.

As a result, the simulated trajectories are all circular arcs, and the most suitable one (we will go into details when talking about the cost function) is selected.

\subsection{Optimization}

The remaining velocities are fed into the following objective function to maximize it:
$$ G(v, \omega) = \sigma(\alpha \cdot heading(v, \omega) + \beta \cdot dist(v, \omega) + \gamma \cdot vel(v, \omega)) $$

This function trades off the following aspects:
\begin{itemize}
 \item \textit{heading}, which is a measure of progress towards the goal location;
 \item \textit{dist}, which is the distance to the closest obstacle on the trajectory;
 \item \textit{vel}, which is the forward velocity of the robot.\\
\end{itemize}

Each one of the three quantities above is multiplied to its own weight ($\alpha$, $\beta$, $\gamma$), and the resulting quantity is passed to a smoothing function ($\sigma$).


%-----------------------------------------------------------------------------
%                               DWA IN ROS
%-----------------------------------------------------------------------------

\section{DWA in ROS}

\subsection{From ROS wiki}

DWA is already implemented in ROS in the \href{https://wiki.ros.org/dwa\_local\_planner}{\texttt{dwa\_local\_planner}}\footnote{https://wiki.ros.org/dwa\_local\_planner} package.

As stated in the ROS Wiki:
\begin{quote}
 ``The dwa\_local\_planner package provides a controller that drives a mobile base in the plane. This controller serves to connect the path planner to the robot. Using a map, the planner creates a kinematic trajectory for the robot to get from a start to a goal location. Along the way, the planner creates, at least locally around the robot, a value function, represented as a grid map. This value function encodes the costs of traversing through the grid cells. The controller's job is to use this value function to determine dx,dy,dtheta velocities to send to the robot.''
\end{quote}

This package is ought to be used as the planner for \href{https://wiki.ros.org/move\_base}{\texttt{move\_base}}\footnote{https://wiki.ros.org/move\_base} within the navigation stack.

In the Wiki there is the following cost function to score each trajectory:

\begin{quote}
    cost =
    path\_distance\_bias * (distance to path from the endpoint of the trajectory)\\
    + goal\_distance\_bias * (distance to local goal from the endpoint of the trajectory)\\
    + occdist\_scale * (maximum obstacle cost along the trajectory in obstacle cost (0-254))
\end{quote}

However, reading through the source code of the DWA ROS library, it is said that the above function is ``used for visualization only, total\_costs are not really total costs''\footnote{https://docs.ros.org/en/melodic/api/dwa\_local\_planner/html/dwa\_\_planner\_8cpp\_source.html (line 184)}.



\subsection{ROS libray source code}

In order to use DWA in our experiment, we call the \texttt{DWAPlannerROS::computeVelocityCommands()} function which leads to the following cascading function calls:\\
\begin{enumerate}

 \item \href{https://docs.ros.org/en/melodic/api/dwa_local_planner/html/dwa\_\_planner\_\_ros\_8cpp\_source.html}{\texttt{DWAPlannerROS::computeVelocityCommands(...)}}\footnote{https://docs.ros.org/en/melodic/api/dwa\_local\_planner/html/dwa\_\_planner\_\_ros\_8cpp\_source.html}
 called in our \texttt{diffdrive\_traj\_ctrl.cpp}, line 78;

 \item \href{https://docs.ros.org/en/melodic/api/dwa\_local\_planner/html/dwa\_\_planner\_\_ros\_8cpp\_source.html}{\texttt{DWAPlannerROS::dwaComputeVelocityCommands(...)}}\footnote{https://docs.ros.org/en/melodic/api/dwa\_local\_planner/html/dwa\_\_planner\_\_ros\_8cpp\_source.html}
 called from the function at step 1, line 302;

 \item \href{https://docs.ros.org/en/melodic/api/dwa\_local\_planner/html/dwa\_\_planner\_8cpp\_source.html}{\texttt{DWAPlanner::findBestPath(...)}}\footnote{https://docs.ros.org/en/melodic/api/dwa\_local\_planner/html/dwa\_\_planner\_8cpp\_source.html}
 called from the function at step 2, line 209;

 \item \href{https://docs.ros.org/en/melodic/api/base\_local\_planner/html/simple\_\_scored\_\_sampling\_\_planner\_8cpp\_source.html}{\texttt{SimpleScoredSamplingPlanner::findBestTrajectory(...)}}\footnote{https://docs.ros.org/en/melodic/api/base\_local\_planner/html/simple\_\_scored\_\_sampling\_\_planner\_8cpp\_source.html}
 called from the function at step 3, line 317;

 \item \href{https://docs.ros.org/en/melodic/api/base\_local\_planner/html/simple\_\_scored\_\_sampling\_\_planner\_8cpp\_source.html}{\texttt{SimpleScoredSamplingPlanner::scoreTrajectory(...)}}\footnote{https://docs.ros.org/en/melodic/api/base\_local\_planner/html/simple\_\_scored\_\_sampling\_\_planner\_8cpp\_source.html}
 called from the function at step 4, line 105.\\

\end{enumerate}

At this point, inside \texttt{scoreTrajectory(...)} the different cost elements are evaluated to score the trajectory.

Each cost element is an instance of the abstract \texttt{base\_local\_planner::TrajectoryCostFunction} class.

These elements are contained in a \texttt{std::vector<TrajectoryCostFunction*>} vector, and in the case of DWA they are:
\begin{itemize}
 \item \texttt{base\_local\_planner::OscillationCostFunction oscillation\_costs\_}, which penalizes trajectories where the robot oscillates;
 \item \texttt{base\_local\_planner::ObstacleCostFunction obstacle\_costs\_}, which penalizes trajectories where the robot occupies illegal positions with its footprint;
 \item \texttt{base\_local\_planner::MapGridCostFunction goal\_front\_costs\_}, which prefers  trajectories that make the nose go towards (local) nose goal;
 \item \texttt{base\_local\_planner::MapGridCostFunction alignment\_costs\_}, which prefers trajectories that keep the robot nose on nose path;
 \item \texttt{base\_local\_planner::MapGridCostFunction path\_costs\_}, which prefers trajectories on global path;
 \item \texttt{base\_local\_planner::MapGridCostFunction goal\_costs\_}, which prefers trajectories that go towards (local) goal;
 \item \texttt{base\_local\_planner::TwirlingCostFunction twirling\_costs\_}, which prefers trajectories that don't spin.\\
\end{itemize}

The considered trajectories by DWA are those taken from a equi-distant discretization of the velocities that the robot can assume. For this purpose ROS has a \href{https://docs.ros.org/en/melodic/api/base\_local\_planner/html/classbase\_\_local\_\_planner\_1\_1SimpleTrajectoryGenerator.html}{\texttt{base\_local\_planner::SimpleTrajectoryGenerator}}\footnote{https://docs.ros.org/en/melodic/api/base\_local\_planner/html/classbase\_\_local\_\_planner\_1\_1SimpleTrajectoryGenerator.html} class.



%-----------------------------------------------------------------------------
%                             SETUP OF THE EXPERIMENT
%-----------------------------------------------------------------------------

\section{Setup of the experiment}

\subsection{The robot}

In our experiment we chose to simulate a small differential drive robot.\\

In particular, it is characterized by two main dimensions (specified as YAML parameters in the code):
\begin{itemize}
 \item \texttt{d} = 15 cm, which is the distance between the two motorized wheels;
 \item \texttt{r} = 3 cm, which is the radius of the two motorized wheels.\\
\end{itemize}

The precise footprint is a pentagon, just for convenience, so that when looking at it we are able to determine the orientation of the robot.
However, this is not a decisive detail since it has o influence on the robot's behavior.


\subsection{The map}

Regarding the map, it is important to highlight the different setting we have with respect to the usual DWA use.

There are two main differences:
\begin{itemize}
 \item in our setting there are no obstacles, neither fixed nor moving;
 \item the robot does not have any sensor.\\
\end{itemize}

As a consequence, we don't need both the local map and the global map, but only the local one.

Moreover, this map needs to be empty so it is generated starting from a totally white image.


\subsection{The trajectory}

The robot must follow a precise trajectory, which is used to perform all benchmarks.

In our case we chose an eight-shaped trajectory with a dimension of 2 x 1 meters.\\

In order to make DWA compute the velocities of the robot, we must feed it a goal.

This means that the complete trajectory has to be "discretized" in multiple points.
Each one of these points is passed to DWA as the current goal, and once it is reached the next point is set as the new goal. You will find a detailed explanation in the following sections.



%-----------------------------------------------------------------------------
%                               IMPLEMENTATION
%-----------------------------------------------------------------------------

\section{Implementation}

\subsection{Architecture overview}

Our implementation is composed of three packages: one simulator (\texttt{diffdrive\_kin\_sim}) and two controllers (\texttt{diffdrive\_kin\_ctrl} and \texttt{diffdrive\_dwa\_ctrl}).

The two controllers are interchangeable and are meant to always be used together with the simulator, one at a time.

\subsection{Service}

\subsubsection{\texttt{generate\_desired\_path\_service}}

The 8-shaped trajectory that the robot must follow is generated inside \texttt{eight\_traj\_gen.cpp} executed in the launch file.

As a result, the two vectors contained in the \texttt{GenerateDesiredPathService.srv} message are populated with the coordinates of all the points of the trajectory.

As soon as the service is called, during the initialization (in the \texttt{Prepare()} function) of both controllers, the complete trajectory is made available also to the controllers.


\subsection{Nodes}

\subsubsection{\texttt{diffdrive\_kin\_sim\_node}}

This node is subscribed to the \texttt{/robot\_input} topic and reads the wheels velocities.

Given those it simulates the movement of the robot and publishes the new position in both \texttt{/robot\_state} and \texttt{/odom} topics. We have decided to keep these two topics separate in order to accommodate both controllers.\\

The actual simulator is an object of the \texttt{diffdrive\_kin\_ode} class, which is initialized as follow:
\begin{lstlisting}
    simulator = new diffdrive_kin_ode(dt);
\end{lstlisting}

and contains the integration logic to update the robot pose.

\subsubsection{\texttt{diffdrive\_kin\_trajctrl\_node}}

This node is dedicated to compute the angular velocities of the two wheels given the current position of the robot and its next point in the trajectory.\\

During the initialization phase it queries the \texttt{generate\_desired\_path\_service} service and stores the complete trajectory.

Then, every time a message is published on the \texttt{/robot\_state} topic this node updates its internal values of the robot pose.\\

The \texttt{PeriodicTask()} that gets executed uses a PID controller and a linearization law (implemented in the \texttt{diffdrive\_kin\_fblin} class) to compute both the linear and the angular velocities of the robot.

As a last step, since the simulated robot is a differential drive one, the angular velocities of the two wheels are computed starting from the $(v, \omega)$ above, and the new results are published on the \texttt{/robot\_input} and \texttt{/controller\_state} topics.

\subsubsection{\texttt{diffdrive\_dwa\_trajctrl\_node}}

This node is used to interface the DWA library in ROS with the simulator.

This is due to the fact that natively DWA is used inside ROS Navigation Stack, thus it expects an odometry source and a costmap.\\

In this specific implementation only a global costmap and a planner (DWA) are used.

As the controller explained above, during the initialiation phase the service is queried. Once the trajectory is received, one point every \texttt{skipped\_goals} is set as the new plan for DWA.

Once the plan is set, the DWA controller tries to reach the new goal position by computing the necessary pair of $(v, \omega)$ velocities. As soon as the goal is reached with a certain tolerance, the next point in the trajectory is set as the new goal.\\

Lastly, the $(\omega_r,\omega_l)$ velocities are computed and published on the \texttt{/robot\_input} and \texttt{/controller\_state} topics.

The implementaion of DWA and all the functions that have been used are provided by the following two files in the ROS library:
href{https://docs.ros.org/en/melodic/api/dwa\_local\_planner/html/dwa\_\_planner\_\_ros\_8cpp\_source.html}{\texttt{dwa\_planner\_ros.cpp}}\footnote{https://docs.ros.org/en/melodic/api/dwa\_local\_planner/html/dwa\_\_planner\_\_ros\_8cpp\_source.html} and href{https://docs.ros.org/en/melodic/api/dwa\_local\_planner/html/dwa\_\_planner\_8cpp\_source.html}{\texttt{dwa\_planner.cpp}}\footnote{https://docs.ros.org/en/melodic/api/dwa\_local\_planner/html/dwa\_\_planner\_8cpp\_source.html}.

(add navigation stack image)

\subsubsection{\texttt{odom\_to\_baselink\_tf\_node}}

This node is needed in order to link the \texttt{odom} and the \texttt{base\_link} coordinate frames through a simple dynamic tf.

\subsection{Frames}

Here is a list with a brief description of all the frames:
\begin{itemize}
 \item \texttt{map}, which is the coordinate system where the empty map (provided by the map server) is;
 \item \texttt{odom}, which represent the global reference system, that in this particular case its origin matches the one of the \texttt{map} frame;
 \item \texttt{base\_link}, which represrents reference system moving around together with the robot.
\end{itemize}

(add tf\_tree image)

\subsection{Topics}

Here is a list with a brief description of the topics that our nodes are subscribed to and published into:\\

\begin{itemize}

    \item \texttt{/clock}, used to synchronize all the nodes in the simulation;

    \item \texttt{/odom}, used to pass the odometry information of the robot to DWA;
        \begin{itemize}
            \item publishers:
                \begin{itemize}
                    \item \texttt{diffdrive\_kin\_sim}
                \end{itemize}
            \item subscribers:
                \begin{itemize}
                    \item \texttt{odom\_to\_baselink\_tf}
                \end{itemize}
        \end{itemize}

    \item \texttt{/robot\_state}, used to pass the odometry information of the robot to the custom controller.
        \begin{itemize}
            \item publishers:
                \begin{itemize}
                    \item \texttt{diffdrive\_kin\_sim}
                \end{itemize}
            \item subscribers:
                \begin{itemize}
                    \item \texttt{diffdrive\_kin\_trajctrl}
                \end{itemize}
        \end{itemize}

    \item \texttt{/controller\_state}, used to publish details about the controller for visualization purposes;
        \begin{itemize}
            \item publishers:
                \begin{itemize}
                    \item \texttt{diffdrive\_kin\_trajctrl}
                    \item \texttt{diffdrive\_dwa\_trajctrl}
                \end{itemize}
            \item subscribers:
                \begin{itemize}
                    \item \textit{none}
                \end{itemize}
        \end{itemize}

    \item \texttt{/robot\_input}, used to communicate $(\omega_r,\omega_l)$ computed by the controllers;
        \begin{itemize}
            \item publishers:
                \begin{itemize}
                    \item \texttt{diffdrive\_kin\_trajctrl}
                    \item \texttt{diffdrive\_dwa\_trajctrl}
                \end{itemize}
            \item subscribers:
                \begin{itemize}
                    \item \texttt{diffdrive\_kin\_sim}
                \end{itemize}
        \end{itemize}

\end{itemize}

\subsection{Launch files}

Here is a list with a brief description of all the launch files:\\
\begin{itemize}
    \item \texttt{diffdrive\_kin\_trajctrl.launch}, used to start the following nodes:
        \begin{itemize}
            \item \texttt{diffdrive\_kin\_sim}
            \item \texttt{diffdrive\_kin\_trajctrl}
            \item \texttt{eight\_traj\_gen}
            \item \texttt{world\_to\_odom} (static tf linking \texttt{world} and \texttt{odom} frames)
            \item \texttt{odom\_visualizer} (\textit{RVIZ} node to visualize data)\\
        \end{itemize}

    \item \texttt{diffdrive\_dwa\_trajctrl.launch}, used to start the following nodes:
        \begin{itemize}
            \item \texttt{diffdrive\_kin\_sim}
            \item \texttt{diffdrive\_dwa\_trajctrl}
            \item \texttt{eight\_traj\_gen}
            \item \texttt{odom\_to\_baselink\_tf}
            \item \texttt{map\_node} (\textit{map\_server} node used to provide the map)
            \item \texttt{map\_to\_odom} (static tf linking \texttt{map} and \texttt{odom} frames)
            \item \texttt{odom\_visualizer} (\textit{RVIZ} node to visualize data)
        \end{itemize}
\end{itemize}


screen rqt\_graph di quando usiamo il nostro controllore e di quando usiamo dwa (messe di fianco)


%-----------------------------------------------------------------------------
%                               PARAMETERS TUNING
%-----------------------------------------------------------------------------

\section{Parameters tuning}

Parameters have a crucial role for the correct functioning of the nodes introduced above.\\

In this section the most relevant ones are explained:\\
\begin{itemize}

    \item \texttt{diffdrive\_kin\_sim.yaml}:
        \begin{itemize}
            \item \texttt{d}, distance between the two wheels;
            \item \texttt{r}, radius of the two wheels.\\
        \end{itemize}

    \item \texttt{eight\_traj.yaml}:
        \begin{itemize}
            \item \texttt{a}, amplitude of the eight-shaped trajectory;
            \item \texttt{w}, ratio $2\pi / T$ where $T$ is the time duration of each lap.\\
        \end{itemize}

    \item \texttt{diffdrive\_kin\_trajctrl.yaml}:
        \begin{itemize}
            \item \texttt{Kp}, proportional gain of the PID controller;
            \item \texttt{Ki}, integral gain of the PID controller;
            \item \texttt{Kd}, derivative gain of the PID controller.\\
        \end{itemize}

    \item \texttt{diffdrive\_dwa\_trajctrl.yaml}:
        \begin{itemize}
            \item \texttt{skipped\_goals}, number of points to skip when feeding the trajectory to DWA.\\
        \end{itemize}

    \item \texttt{dwa\_planner\_params.yaml}:
        \begin{itemize}
            \item \texttt{min\_vel\_y}, minimum linear velocity along the y-axis;
            \item \texttt{max\_vel\_y}, maximum linear velocity along the y-axis;
            \item \texttt{min\_vel\_x}, minimum linear velocity along the x-axis;
            \item \texttt{max\_vel\_x}, minimum linear velocity along the x-axis;
            \item \texttt{acc\_lim\_theta}, maximum angular acceleration;
            \item \texttt{vth\_samples}, number of samples of $\omega$ that DWA considers when simulating;
            \item \texttt{vx\_samples}, number of samples of $v$ that DWA considers when simulating;
            \item \texttt{path\_distance\_bias}, weighting for how much the controller should stay close to the given path;
            \item \texttt{goal\_distance\_bias}, weighting for how much the controller should attempt to reach its local goal;
            \item \texttt{xy\_goal\_tolerance}, tolerance (in meters) in the x \& y distance when reaching a goal;
            \item \texttt{yaw\_goal\_tolerance}, tolerance (in radians) in yaw/rotation when reaching a goal .\\
        \end{itemize}

\end{itemize}


... (number of points when discretizing the trajectory: t+=0.001... MAKE IT PARAMETER!!)



%-----------------------------------------------------------------------------
%                               EXPERIMENTAL RESULTS
%-----------------------------------------------------------------------------

\section{Experimental Results}

... (plots of the bags + plots of the comparison with the custom script)



%-----------------------------------------------------------------------------
%                               ENCOUNTERED PROBLEMS
%-----------------------------------------------------------------------------

\section{Encountered problems}

... (deprecated parameters name in the official doc: put screen of the doc +
screen of the comments in the code of the library)
% 


%-----------------------------------------------------------------------------
%                               USAGE OF THE CODE
%-----------------------------------------------------------------------------

\section{Usage of the code}

...



%-----------------------------------------------------------------------------
%                               CONCLUSIONS
%-----------------------------------------------------------------------------

\section{Conclusions}

...



\end{document}
